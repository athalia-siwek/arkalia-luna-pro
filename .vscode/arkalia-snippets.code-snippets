{
    "Arkalia Log Pattern": {
        "prefix": "logia",
        "body": [
            "logger.info('üåï [${1:MODULE}] ${2:message}')"
        ],
        "description": "Snippet log structur√© Arkalia avec emoji"
    },
    "Arkalia Error Log": {
        "prefix": "logerr",
        "body": [
            "logger.error('‚ùå [${1:MODULE}] ${2:error_message}')"
        ],
        "description": "Snippet log d'erreur Arkalia"
    },
    "Arkalia Warning Log": {
        "prefix": "logwarn",
        "body": [
            "logger.warning('‚ö†Ô∏è [${1:MODULE}] ${2:warning_message}')"
        ],
        "description": "Snippet log d'avertissement Arkalia"
    },
    "Arkalia Success Log": {
        "prefix": "logok",
        "body": [
            "logger.info('‚úÖ [${1:MODULE}] ${2:success_message}')"
        ],
        "description": "Snippet log de succ√®s Arkalia"
    },
    "Arkalia Commit": {
        "prefix": "acmt",
        "body": [
            "üîÅ ${1:Module} | ${2:Fix/Refactor/Feature}: ${3:Short message}"
        ],
        "description": "Style commit Arkalia avec emoji"
    },
    "Arkalia Function Doc": {
        "prefix": "adoc",
        "body": [
            "\"\"\"",
            "üß† ${1:Description de la fonction}",
            "",
            "Args:",
            "    ${2:param}: ${3:description}",
            "",
            "Returns:",
            "    ${4:type}: ${5:description}",
            "",
            "Raises:",
            "    ${6:Exception}: ${7:description}",
            "\"\"\""
        ],
        "description": "Documentation de fonction style Arkalia"
    },
    "Arkalia Class Doc": {
        "prefix": "aclass",
        "body": [
            "\"\"\"",
            "üåï ${1:Nom de la classe} - ${2:Description}",
            "",
            "Cette classe fait partie du module ${3:module_name}",
            "et g√®re ${4:responsabilit√©}",
            "\"\"\""
        ],
        "description": "Documentation de classe style Arkalia"
    },
    "Arkalia TODO": {
        "prefix": "atodo",
        "body": [
            "# üåï TODO: ${1:description}",
            "#    Priorit√©: ${2:high/medium/low}",
            "#    Assign√©: ${3:qui}",
            "#    Deadline: ${4:date}"
        ],
        "description": "TODO style Arkalia avec structure"
    },
    "Arkalia FIXME": {
        "prefix": "afix",
        "body": [
            "# ‚ùå FIXME: ${1:description du bug}",
            "#    Module: ${2:module_name}",
            "#    Impact: ${3:high/medium/low}",
            "#    Solution: ${4:description de la solution}"
        ],
        "description": "FIXME style Arkalia avec structure"
    },
    "Arkalia Test Function": {
        "prefix": "atest",
        "body": [
            "def test_${1:function_name}():",
            "    \"\"\"üß™ Test de ${2:description du test}\"\"\"",
            "    # Arrange",
            "    ${3:setup_code}",
            "    ",
            "    # Act",
            "    ${4:action_code}",
            "    ",
            "    # Assert",
            "    ${5:assertion_code}"
        ],
        "description": "Structure de test Arkalia avec AAA pattern"
    },
    "Arkalia Async Function": {
        "prefix": "aasync",
        "body": [
            "async def ${1:function_name}(${2:params}):",
            "    \"\"\"üß† Fonction asynchrone ${3:description}\"\"\"",
            "    try:",
            "        ${4:async_code}",
            "        return ${5:result}",
            "    except Exception as e:",
            "        logger.error(f'‚ùå Erreur dans {1}: {e}')",
            "        raise"
        ],
        "description": "Fonction asynchrone avec gestion d'erreur Arkalia"
    },
    "Arkalia Config Section": {
        "prefix": "aconfig",
        "body": [
            "# === ${1:SECTION_NAME} === #",
            "# ${2:Description de la section}",
            "# Version: ${3:version}",
            "",
            "${4:config_content}"
        ],
        "description": "Section de configuration style Arkalia"
    },
    "Arkalia Module Header": {
        "prefix": "aheader",
        "body": [
            "#!/usr/bin/env python3",
            "# üß† ${1:module_name}.py",
            "# ${2:Description du module}",
            "",
            "\"\"\"",
            "üåï ${3:Nom du module} - ${4:Description compl√®te}",
            "",
            "Ce module fait partie d'Arkalia-LUNA Pro v${5:version}",
            "et g√®re ${6:responsabilit√©}",
            "\"\"\""
        ],
        "description": "En-t√™te de module Arkalia avec documentation"
    },
    "Arkalia Import Section": {
        "prefix": "aimp",
        "body": [
            "# === IMPORTS === #",
            "import ${1:standard_lib}",
            "from ${2:third_party} import ${3:module}",
            "from modules.${4:arkalia_module} import ${5:component}",
            "",
            "# === LOGGING === #",
            "import logging",
            "logger = logging.getLogger(__name__)"
        ],
        "description": "Section d'imports style Arkalia avec logging"
    },
    "üåï Arkalia Module Template": {
        "prefix": "ark-module",
        "body": [
            "#!/usr/bin/env python3",
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "üåï Arkalia-LUNA Module: ${1:Module Name}",
            "üìù Description: ${2:Module description}",
            "üîß Version: ${3:1.0.0}",
            "üë§ Author: Athalia",
            "üìÖ Created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE}",
            "\"\"\"",
            "",
            "import logging",
            "import asyncio",
            "from typing import Optional, Dict, Any, List",
            "from dataclasses import dataclass",
            "from pathlib import Path",
            "",
            "# Configuration du logging Arkalia",
            "logger = logging.getLogger(__name__)",
            "logger.setLevel(logging.INFO)",
            "",
            "",
            "@dataclass",
            "class ${1/(.*)/${1:/capitalize}/}Config:",
            "    \"\"\"Configuration pour ${1:Module Name}\"\"\"",
            "    enabled: bool = True",
            "    debug_mode: bool = False",
            "    max_retries: int = 3",
            "    timeout: float = 30.0",
            "",
            "",
            "class ${1/(.*)/${1:/capitalize}/}Core:",
            "    \"\"\"Core logic pour ${1:Module Name}\"\"\"",
            "    ",
            "    def __init__(self, config: ${1/(.*)/${1:/capitalize}/}Config):",
            "        self.config = config",
            "        self.logger = logging.getLogger(f\"arkalia.${1:module_name}\")",
            "        self._initialize()",
            "    ",
            "    def _initialize(self) -> None:",
            "        \"\"\"Initialisation du module\"\"\"",
            "        self.logger.info(\"üåï ${1:Module Name} initialis√©\")",
            "    ",
            "    async def process(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        \"\"\"Traitement principal\"\"\"",
            "        try:",
            "            self.logger.info(f\"üß† Traitement: {data}\")",
            "            # TODO: Impl√©menter la logique",
            "            return {\"status\": \"success\", \"data\": data}",
            "        except Exception as e:",
            "            self.logger.error(f\"‚ùå Erreur: {e}\")",
            "            return {\"status\": \"error\", \"error\": str(e)}",
            "    ",
            "    def health_check(self) -> Dict[str, Any]:",
            "        \"\"\"V√©rification de sant√©\"\"\"",
            "        return {",
            "            \"module\": \"${1:module_name}\",",
            "            \"status\": \"healthy\",",
            "            \"version\": \"${3:1.0.0}\"",
            "        }",
            "",
            "",
            "async def main():",
            "    \"\"\"Fonction principale\"\"\"",
            "    config = ${1/(.*)/${1:/capitalize}/}Config()",
            "    core = ${1/(.*)/${1:/capitalize}/}Core(config)",
            "    ",
            "    # Test du module",
            "    result = await core.process({\"test\": \"data\"})",
            "    print(f\"‚úÖ R√©sultat: {result}\")",
            "    ",
            "    health = core.health_check()",
            "    print(f\"üè• Sant√©: {health}\")",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    asyncio.run(main())"
        ],
        "description": "Template complet pour un nouveau module Arkalia-LUNA"
    },
    "üß† Arkalia Test Template": {
        "prefix": "ark-test",
        "body": [
            "#!/usr/bin/env python3",
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "üß™ Tests pour ${1:Module Name}",
            "üìù Test suite: ${2:Test description}",
            "üîß Version: ${3:1.0.0}",
            "üë§ Author: Athalia",
            "üìÖ Created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE}",
            "\"\"\"",
            "",
            "import pytest",
            "import asyncio",
            "from unittest.mock import Mock, patch, AsyncMock",
            "from typing import Dict, Any",
            "",
            "# Import du module √† tester",
            "from modules.${1:module_name}.core import ${1/(.*)/${1:/capitalize}/}Core, ${1/(.*)/${1:/capitalize}/}Config",
            "",
            "",
            "@pytest.fixture",
            "def config():",
            "    \"\"\"Configuration de test\"\"\"",
            "    return ${1/(.*)/${1:/capitalize}/}Config(",
            "        enabled=True,",
            "        debug_mode=True,",
            "        max_retries=1,",
            "        timeout=5.0",
            "    )",
            "",
            "",
            "@pytest.fixture",
            "def core(config):",
            "    \"\"\"Instance du core pour les tests\"\"\"",
            "    return ${1/(.*)/${1:/capitalize}/}Core(config)",
            "",
            "",
            "class Test${1/(.*)/${1:/capitalize}/}Core:",
            "    \"\"\"Tests pour ${1:Module Name} Core\"\"\"",
            "    ",
            "    def test_initialization(self, config):",
            "        \"\"\"Test d'initialisation\"\"\"",
            "        core = ${1/(.*)/${1:/capitalize}/}Core(config)",
            "        assert core.config == config",
            "        assert core.logger is not None",
            "    ",
            "    ",
            "    @pytest.mark.asyncio",
            "    async def test_process_success(self, core):",
            "        \"\"\"Test de traitement r√©ussi\"\"\"",
            "        test_data = {\"test\": \"value\"}",
            "        result = await core.process(test_data)",
            "        ",
            "        assert result[\"status\"] == \"success\"",
            "        assert result[\"data\"] == test_data",
            "    ",
            "    ",
            "    @pytest.mark.asyncio",
            "    async def test_process_error(self, core):",
            "        \"\"\"Test de gestion d'erreur\"\"\"",
            "        with patch.object(core, 'process', side_effect=Exception(\"Test error\")):",
            "            result = await core.process({\"test\": \"data\"})",
            "            assert result[\"status\"] == \"error\"",
            "            assert \"Test error\" in result[\"error\"]",
            "    ",
            "    ",
            "    def test_health_check(self, core):",
            "        \"\"\"Test de v√©rification de sant√©\"\"\"",
            "        health = core.health_check()",
            "        ",
            "        assert health[\"module\"] == \"${1:module_name}\"",
            "        assert health[\"status\"] == \"healthy\"",
            "        assert \"version\" in health",
            "",
            "",
            "class Test${1/(.*)/${1:/capitalize}/}Config:",
            "    \"\"\"Tests pour la configuration\"\"\"",
            "    ",
            "    def test_default_config(self):",
            "        \"\"\"Test des valeurs par d√©faut\"\"\"",
            "        config = ${1/(.*)/${1:/capitalize}/}Config()",
            "        ",
            "        assert config.enabled is True",
            "        assert config.debug_mode is False",
            "        assert config.max_retries == 3",
            "        assert config.timeout == 30.0",
            "    ",
            "    ",
            "    def test_custom_config(self):",
            "        \"\"\"Test de configuration personnalis√©e\"\"\"",
            "        config = ${1/(.*)/${1:/capitalize}/}Config(",
            "            enabled=False,",
            "            debug_mode=True,",
            "            max_retries=5,",
            "            timeout=60.0",
            "        )",
            "        ",
            "        assert config.enabled is False",
            "        assert config.debug_mode is True",
            "        assert config.max_retries == 5",
            "        assert config.timeout == 60.0",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    pytest.main([__file__, \"-v\"])"
        ],
        "description": "Template complet pour les tests Arkalia-LUNA"
    },
    "üöÄ Arkalia Performance Test": {
        "prefix": "ark-perf",
        "body": [
            "#!/usr/bin/env python3",
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "üöÄ Test de performance pour ${1:Module Name}",
            "üìù Performance test: ${2:Performance description}",
            "üîß Version: ${3:1.0.0}",
            "üë§ Author: Athalia",
            "üìÖ Created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE}",
            "\"\"\"",
            "",
            "import pytest",
            "import asyncio",
            "import time",
            "import statistics",
            "from typing import List, Dict, Any",
            "from dataclasses import dataclass",
            "",
            "",
            "@dataclass",
            "class PerformanceResult:",
            "    \"\"\"R√©sultat de test de performance\"\"\"",
            "    operation: str",
            "    duration: float",
            "    success: bool",
            "    error: Optional[str] = None",
            "",
            "",
            "class ${1/(.*)/${1:/capitalize}/}PerformanceTest:",
            "    \"\"\"Tests de performance pour ${1:Module Name}\"\"\"",
            "    ",
            "    def __init__(self):",
            "        self.results: List[PerformanceResult] = []",
            "    ",
            "    ",
            "    async def measure_operation(self, operation_name: str, operation_func, *args, **kwargs) -> PerformanceResult:",
            "        \"\"\"Mesure la performance d'une op√©ration\"\"\"",
            "        start_time = time.time()",
            "        try:",
            "            result = await operation_func(*args, **kwargs)",
            "            duration = time.time() - start_time",
            "            return PerformanceResult(",
            "                operation=operation_name,",
            "                duration=duration,",
            "                success=True",
            "            )",
            "        except Exception as e:",
            "            duration = time.time() - start_time",
            "            return PerformanceResult(",
            "                operation=operation_name,",
            "                duration=duration,",
            "                success=False,",
            "                error=str(e)",
            "            )",
            "    ",
            "    ",
            "    def generate_report(self) -> Dict[str, Any]:",
            "        \"\"\"G√©n√®re un rapport de performance\"\"\"",
            "        successful_ops = [r for r in self.results if r.success]",
            "        failed_ops = [r for r in self.results if not r.success]",
            "        ",
            "        if successful_ops:",
            "            durations = [r.duration for r in successful_ops]",
            "            report = {",
            "                \"total_operations\": len(self.results),",
            "                \"successful_operations\": len(successful_ops),",
            "                \"failed_operations\": len(failed_ops),",
            "                \"success_rate\": len(successful_ops) / len(self.results),",
            "                \"avg_duration\": statistics.mean(durations),",
            "                \"min_duration\": min(durations),",
            "                \"max_duration\": max(durations),",
            "                \"median_duration\": statistics.median(durations),",
            "                \"std_duration\": statistics.stdev(durations) if len(durations) > 1 else 0,",
            "            }",
            "        else:",
            "            report = {",
            "                \"total_operations\": len(self.results),",
            "                \"successful_operations\": 0,",
            "                \"failed_operations\": len(failed_ops),",
            "                \"success_rate\": 0.0,",
            "                \"error\": \"Aucune op√©ration r√©ussie\"",
            "            }",
            "        ",
            "        return report",
            "",
            "",
            "@pytest.mark.performance",
            "class Test${1/(.*)/${1:/capitalize}/}Performance:",
            "    \"\"\"Tests de performance\"\"\"",
            "    ",
            "    @pytest.mark.asyncio",
            "    async def test_${1:module_name}_performance(self):",
            "        \"\"\"Test de performance principal\"\"\"",
            "        # TODO: Impl√©menter les tests de performance",
            "        pass",
            "    ",
            "    ",
            "    @pytest.mark.asyncio",
            "    async def test_${1:module_name}_latency_under_threshold(self):",
            "        \"\"\"Test que la latence reste sous le seuil\"\"\"",
            "        # TODO: Impl√©menter le test de latence",
            "        pass",
            "    ",
            "    ",
            "    @pytest.mark.asyncio",
            "    async def test_${1:module_name}_throughput(self):",
            "        \"\"\"Test de d√©bit\"\"\"",
            "        # TODO: Impl√©menter le test de d√©bit",
            "        pass",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    pytest.main([__file__, \"-v\", \"-m\", \"performance\"])"
        ],
        "description": "Template pour tests de performance Arkalia-LUNA"
    },
    "ZeroIA Reason Loop": {
        "prefix": "zeroia-loop",
        "body": [
            "def reason_loop() -> None:",
            "    \"\"\"Boucle de raisonnement ZeroIA\"\"\"",
            "    try:",
            "        # Initialisation",
            "        state = load_zeroia_state()",
            "        ",
            "        # Logique de raisonnement",
            "        decision = analyze_situation(state)",
            "        ",
            "        # Mise √† jour de l'√©tat",
            "        update_state(state, decision)",
            "        ",
            "        # Sauvegarde",
            "        save_zeroia_state(state)",
            "        ",
            "    except Exception as e:",
            "        logger.error(f\"Erreur dans reason_loop: {e}\")",
            "        handle_error(e)",
            ""
        ],
        "description": "Template pour une boucle de raisonnement ZeroIA"
    },
    "Circuit Breaker": {
        "prefix": "circuit",
        "body": [
            "@circuit_breaker(",
            "    failure_threshold=5,",
            "    recovery_timeout=60,",
            "    expected_exception=Exception",
            ")",
            "def ${1:function_name}(${2:args}) -> ${3:Any}:",
            "    \"\"\"${4:Description}\"\"\"",
            "    ${5:pass}",
            ""
        ],
        "description": "D√©corateur circuit breaker pour ZeroIA"
    },
    "Event Store": {
        "prefix": "event-store",
        "body": [
            "class ${1:EventStore}:",
            "    \"\"\"Stockage d'√©v√©nements pour ${2:module_name}\"\"\"",
            "    ",
            "    def __init__(self, cache_dir: str = \"./cache/${3:events}\") -> None:",
            "        self.cache_dir = Path(cache_dir)",
            "        self.cache_dir.mkdir(parents=True, exist_ok=True)",
            "        self.events: dict[str, dict[str, Any]] = {}",
            "        self.event_counter = 0",
            "    ",
            "    def add_event(self, event_type: str, data: dict[str, Any]) -> None:",
            "        \"\"\"Ajoute un √©v√©nement\"\"\"",
            "        event_id = f\"{event_type}_{self.event_counter}\"",
            "        self.events[event_id] = {",
            "            \"type\": event_type,",
            "            \"data\": data,",
            "            \"timestamp\": datetime.now().isoformat()",
            "        }",
            "        self.event_counter += 1",
            "        self._save_events()",
            "    ",
            "    def _save_events(self) -> None:",
            "        \"\"\"Sauvegarde les √©v√©nements\"\"\"",
            "        with open(self.cache_dir / \"events.json\", \"w\") as f:",
            "            json.dump(self.events, f, indent=2)",
            ""
        ],
        "description": "Template pour un Event Store"
    },
    "State Writer": {
        "prefix": "state-writer",
        "body": [
            "class ${1:StateWriter}:",
            "    \"\"\"Gestionnaire d'√©tat pour ${2:module_name}\"\"\"",
            "    ",
            "    def __init__(self, state_file: str = \"./state/${3:state}.toml\") -> None:",
            "        self.state_file = Path(state_file)",
            "        self.state_file.parent.mkdir(parents=True, exist_ok=True)",
            "        self.state = self._load_state()",
            "    ",
            "    def _load_state(self) -> dict[str, Any]:",
            "        \"\"\"Charge l'√©tat depuis le fichier\"\"\"",
            "        if self.state_file.exists():",
            "            return tomllib.loads(self.state_file.read_text())",
            "        return {}",
            "    ",
            "    def save_state(self, data: dict[str, Any]) -> None:",
            "        \"\"\"Sauvegarde l'√©tat\"\"\"",
            "        self.state.update(data)",
            "        with open(self.state_file, \"w\") as f:",
            "            tomli_w.dump(self.state, f)",
            ""
        ],
        "description": "Template pour un State Writer"
    },
    "Test Template": {
        "prefix": "test-template",
        "body": [
            "import pytest",
            "from ${1:module_path} import ${2:ClassName}",
            "",
            "",
            "class Test${2:ClassName}:",
            "    \"\"\"Tests pour ${2:ClassName}\"\"\"",
            "    ",
            "    def setup_method(self) -> None:",
            "        \"\"\"Setup avant chaque test\"\"\"",
            "        self.${3:instance} = ${2:ClassName}()",
            "    ",
            "    def test_${4:method_name}(self) -> None:",
            "        \"\"\"Test de ${4:method_name}\"\"\"",
            "        # Arrange",
            "        ${5:expected} = ${6:value}",
            "        ",
            "        # Act",
            "        ${7:result} = self.${3:instance}.${4:method_name}()",
            "        ",
            "        # Assert",
            "        assert ${7:result} == ${5:expected}",
            ""
        ],
        "description": "Template pour un test unitaire"
    },
    "FastAPI Route": {
        "prefix": "fastapi-route",
        "body": [
            "from fastapi import APIRouter, HTTPException",
            "from pydantic import BaseModel",
            "from typing import Any",
            "",
            "",
            "router = APIRouter(prefix=\"/${1:api}\", tags=[\"${2:tag}\"])",
            "",
            "",
            "class ${3:RequestModel}(BaseModel):",
            "    \"\"\"Mod√®le de requ√™te\"\"\"",
            "    ${4:field}: ${5:str}",
            "",
            "",
            "class ${6:ResponseModel}(BaseModel):",
            "    \"\"\"Mod√®le de r√©ponse\"\"\"",
            "    ${7:result}: ${8:str}",
            "",
            "",
            "@router.post(\"/${9:endpoint}\", response_model=${6:ResponseModel})",
            "async def ${10:function_name}(request: ${3:RequestModel}) -> ${6:ResponseModel}:",
            "    \"\"\"${11:Description de l'endpoint}\"\"\"",
            "    try:",
            "        # Logique m√©tier",
            "        ${12:result} = process_${10:function_name}(request)",
            "        ",
            "        return ${6:ResponseModel}(${7:result}=${12:result})",
            "        ",
            "    except Exception as e:",
            "        raise HTTPException(status_code=500, detail=str(e))",
            ""
        ],
        "description": "Template pour une route FastAPI"
    },
    "Logging Setup": {
        "prefix": "logging-setup",
        "body": [
            "import logging",
            "from pathlib import Path",
            "from datetime import datetime",
            "",
            "",
            "def setup_logging(module_name: str, log_dir: str = \"./logs\") -> logging.Logger:",
            "    \"\"\"Configure le logging pour ${1:module_name}\"\"\"",
            "    # Cr√©er le dossier de logs",
            "    log_path = Path(log_dir)",
            "    log_path.mkdir(parents=True, exist_ok=True)",
            "    ",
            "    # Configuration du logger",
            "    logger = logging.getLogger(module_name)",
            "    logger.setLevel(logging.INFO)",
            "    ",
            "    # Handler fichier",
            "    file_handler = logging.FileHandler(",
            "        log_path / f\"{module_name}_{datetime.now().strftime('%Y%m%d')}.log\"",
            "    )",
            "    file_handler.setLevel(logging.INFO)",
            "    ",
            "    # Handler console",
            "    console_handler = logging.StreamHandler()",
            "    console_handler.setLevel(logging.INFO)",
            "    ",
            "    # Format",
            "    formatter = logging.Formatter(",
            "        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'",
            "    )",
            "    file_handler.setFormatter(formatter)",
            "    console_handler.setFormatter(formatter)",
            "    ",
            "    # Ajouter les handlers",
            "    logger.addHandler(file_handler)",
            "    logger.addHandler(console_handler)",
            "    ",
            "    return logger",
            ""
        ],
        "description": "Template pour la configuration du logging"
    }
}
